using Godot;
using System;
using System.Collections.Generic;

public partial class Level7Part2 : Node2D 
{
	private const string PlayerGroupName = "player";
	private const string SpawnMarkerName = "Level7Part2_Spawn";
	
	// --- Dusty Sandstorm Constants (EXTREME INTENSITY SETTINGS) ---
	private const int SAND_PARTICLE_COUNT = 1000;       // Extreme particle count
	private const float WIND_SPEED_MIN = 350.0f;        
	private const float WIND_SPEED_MAX = 750.0f;        // Fast, intense horizontal movement
	private const float WIND_JITTER = 75.0f;            // Vertical turbulence
	private const float SAND_OPACITY = 0.7f;            // High clarity
	private const float SAND_SIZE_MIN = 2.0f;           
	private const float SAND_SIZE_MAX = 4.0f;           
	// Lighter brown/tan/beige color
	private Color SAND_COLOR = new Color(0.95f, 0.8f, 0.5f, SAND_OPACITY); 
	
	private RandomNumberGenerator _rng = new RandomNumberGenerator();
	private Vector2 _viewportSize;

	// Structure to hold particle data
	private struct SandParticle
	{
		public Vector2 Position;
		public float Size;
		public float Speed;         
		public float VerticalJitter; 
	}

	private List<SandParticle> _particles = new List<SandParticle>();
	private Node2D _drawingNode;

	public override void _Ready()
	{
		GD.Print("Level 7 Part 2 Loaded. Attempting to spawn player...");
		
		_rng.Seed = (ulong)DateTime.Now.Ticks;
		_viewportSize = GetViewportRect().Size;
		
		// 1. --- Player Spawning Logic ---
		SpawnPlayer();

		// 2. --- Sandstorm Particle Logic ---
		InitializeSandstorm();
	}

// --- Player Spawning Logic (Unchanged) ---
	
	private void SpawnPlayer()
	{
		Node2D player = null;Â 

		foreach (Node node in GetTree().Root.GetChildren())
		{
			if (node.IsInGroup(PlayerGroupName) && node.Name == "CharacterNode" && node is Node2D playerNode)
			{
				player = playerNode;
				break;
			}
		}

		if (player == null)
		{
			GD.PrintErr("Could not find player in the scene tree!");
			return;
		}

		var spawnPoint = GetNodeOrNull<Marker2D>(SpawnMarkerName);

		if (spawnPoint != null)
		{
			player.GlobalPosition = spawnPoint.GlobalPosition;
			GD.Print($"Player successfully spawned at: {player.GlobalPosition}");
		}
		else
		{
			GD.PrintErr($"Could not find spawn marker: {SpawnMarkerName}. Player may be stuck at (0, 0).");
		}
	}

// --------------------------------------------------------------------------
// MANUAL MOVEMENT LOGIC (Sand)
// --------------------------------------------------------------------------

	public override void _Process(double delta)
	{
		// 1. Update Particle Positions
		for (int i = 0; i < _particles.Count; i++)
		{
			SandParticle p = _particles[i];
			float dt = (float)delta;
			
			// Apply main horizontal movement (wind)
			p.Position.X += p.Speed * dt;
			
			// Apply chaotic vertical jitter (turbulence)
			p.Position.Y += p.VerticalJitter * dt;
			
			// Periodically reset vertical jitter for chaotic movement
			if (_rng.Randf() < 0.1f) 
			{
				p.VerticalJitter = _rng.RandfRange(-WIND_JITTER, WIND_JITTER);
			}

			// --- Boundary Check: Wrap to the left side if it exits right ---
			if (p.Position.X > _viewportSize.X + p.Size)
			{
				p.Position = ResetSandPosition(p.Size);
			}
			// Boundary Check: Keep the sand particles constrained vertically
			if (p.Position.Y > _viewportSize.Y) p.Position.Y = -p.Size;
			if (p.Position.Y < -p.Size) p.Position.Y = _viewportSize.Y;

			_particles[i] = p; 
		}
		
		// 2. Redraw the particles on the screen
		if (_drawingNode != null)
		{
			_drawingNode.QueueRedraw();
		}
	}
	
// --------------------------------------------------------------------------
// SANDSTORM DRAWING LOGIC
// --------------------------------------------------------------------------

	private void InitializeSandstorm()
	{
		// 1. Setup the CanvasLayer and the Drawing Node
		CanvasLayer sandLayer = new CanvasLayer();
		sandLayer.Layer = 100; // High layer to draw over everything
		AddChild(sandLayer);

		_drawingNode = new Node2D();
		_drawingNode.Name = "SandDrawingNode";
		_drawingNode.SetProcessMode(Node.ProcessModeEnum.Always); 
		_drawingNode.Draw += OnSandDraw; 
		sandLayer.AddChild(_drawingNode);
		
		// 2. Populate the particle data list
		for (int i = 0; i < SAND_PARTICLE_COUNT; i++)
		{
			SandParticle p = new SandParticle();
			p.Size = _rng.RandfRange(SAND_SIZE_MIN, SAND_SIZE_MAX);
			p.Speed = _rng.RandfRange(WIND_SPEED_MIN, WIND_SPEED_MAX);
			
			// Initial random setup
			p.Position = ResetSandPosition(p.Size, true);
			p.VerticalJitter = _rng.RandfRange(-WIND_JITTER, WIND_JITTER);
			
			_particles.Add(p);
		}
		
		GD.Print($"Initialized {SAND_PARTICLE_COUNT} procedural sandstorm particles.");
	}

	/// <summary>
	/// Custom draw function executed when _drawingNode.QueueRedraw() is called.
	/// </summary>
	private void OnSandDraw()
	{
		foreach (var p in _particles)
		{
			// Draw the rectangle using the constant sand color
			Rect2 rect = new Rect2(p.Position - new Vector2(p.Size/2, p.Size/2), new Vector2(p.Size, p.Size));
			_drawingNode.DrawRect(rect, SAND_COLOR);
		}
	}
	
	/// <summary>
	/// Calculates a new starting position for a sand particle.
	/// </summary>
	private Vector2 ResetSandPosition(float size, bool initialPlacement = false)
	{
		// Start just off the left side of the screen or randomly across the screen initially
		float startX = initialPlacement ? _rng.RandfRange(0, _viewportSize.X) : _rng.RandfRange(-size, -10.0f);
		
		// Start anywhere vertically
		float startY = _rng.RandfRange(0, _viewportSize.Y); 

		return new Vector2(startX, startY);
	}
}
