using Godot;
using System;
using System.Linq;

public partial class Blackrat : CharacterBody2D
{
	[Export] public float Speed { get; set; } = 150f;
	[Export] public int AttackDamage { get; set; } = 1;
	[Export] public float AttackCooldown { get; set; } = 1.5f;
	[Export] public float AttackRange { get; set; } = 50f;
	[Export] public int MaxHealth { get; set; } = 70;
	[Export] public float DetectionRadius { get; set; } = 500f;
	[Export] public float WanderSpeedMultiplier { get; set; } = 0.20f;
	
	[Export] public float WallDetectionDistance { get; set; } = 50f;
	private const float WallAvoidanceAngle = Mathf.Pi / 20f; // 60 degrees
	private const float AttackHitDelay = 0.1f; // Time in seconds when the attack damage should land

	[Export] public string AttackAnimationName { get; set; } = "attack";
	// New export property for how long the health bar stays visible after being hit
	[Export] public float HealthBarVisibilityTime { get; set; } = 3.0f; 

	private AnimatedSprite2D _sprite;
	private Random _rng = new Random();
	
	private RayCast2D _rayFwd;
	private RayCast2D _rayLeft;
	private RayCast2D _rayRight;
	
	private Timer _damageTimer; // Timer to precisely time the hit point
	private float _wanderAngle = 0f;
	private float _wanderChangeDelay = 0f;

	private int _currentHealth;
	private float _attackCooldownTimer = 0f;

	private bool _isAttacking = false;

	private CharacterNode _player;
	private float _dt;

	private Timer _playerSearchTimer;
	private Timer _healthBarVisibleTimer; // Timer to hide the health bar

	private Vector2 _lastDirection = Vector2.Down;

	private const float VerticalDominanceBias = 0.15f;
	
	// --- Health Bar Properties ---
	private Node2D _healthBarContainer;
	private ProgressBar _healthBar;
	// Keeping user-defined values: -1f offset and 3f height
	private const float HealthBarHeightOffset = -1f; 
	private const float HealthBarWidth = 70f;
	private const float HealthBarHeight = 3f;
	// ---------------------------


	public override void _Ready()
	{
		AddToGroup("enemy");

		_sprite = GetNodeOrNull<AnimatedSprite2D>("AnimatedSprite2D");
		
		_rayFwd = GetNodeOrNull<RayCast2D>("RayCastFwd");
		_rayLeft = GetNodeOrNull<RayCast2D>("RayCastLeft");
		_rayRight = GetNodeOrNull<RayCast2D>("RayCastRight");
		
		// Setup Damage Timer for precise hit timing
		_damageTimer = new Timer();
		AddChild(_damageTimer);
		_damageTimer.OneShot = true;
		_damageTimer.WaitTime = AttackHitDelay;
		_damageTimer.Timeout += ApplyDamage; // Connect to the new damage function

		// Initialize RayCast target positions
		if (_rayFwd != null) _rayFwd.TargetPosition = Vector2.Right * WallDetectionDistance;
		if (_rayLeft != null) _rayLeft.TargetPosition = Vector2.Right.Rotated(-WallAvoidanceAngle / 2) * WallDetectionDistance;
		if (_rayRight != null) _rayRight.TargetPosition = Vector2.Right.Rotated(WallAvoidanceAngle / 2) * WallDetectionDistance;

		if (_sprite != null)
		{
			_sprite.Connect(
				AnimatedSprite2D.SignalName.AnimationFinished,
				new Callable(this, nameof(OnAttackAnimationFinished))
			);
		}

		_currentHealth = MaxHealth;
		
		// --- Health Bar Setup ---
		CreateHealthBar();
		// ----------------------
		
		// --- Health Bar Visibility Timer Setup ---
		_healthBarVisibleTimer = new Timer();
		AddChild(_healthBarVisibleTimer);
		_healthBarVisibleTimer.OneShot = true;
		_healthBarVisibleTimer.WaitTime = HealthBarVisibilityTime;
		_healthBarVisibleTimer.Timeout += HideHealthBar;
		// -----------------------------------------

		_wanderAngle = (float)(_rng.NextDouble() * Math.PI * 2);
		_wanderChangeDelay = 1f + (float)_rng.NextDouble() * 2f;

		_playerSearchTimer = new Timer();
		AddChild(_playerSearchTimer);
		_playerSearchTimer.WaitTime = 2.0f;
		_playerSearchTimer.Timeout += FindPlayer;
		_playerSearchTimer.Start();

		FindPlayer();
	}
	
	private void CreateHealthBar()
	{
		// 1. Container for positioning (Node2D)
		_healthBarContainer = new Node2D();
		_healthBarContainer.Name = "HealthBarContainer";
		// Position the container above the character's pivot
		_healthBarContainer.Position = new Vector2(0, HealthBarHeightOffset);
		AddChild(_healthBarContainer);

		// 2. The Health Bar itself (ProgressBar)
		_healthBar = new ProgressBar();
		_healthBar.Name = "HealthBar";
		
		// Set size and appearance
		_healthBar.Size = new Vector2(HealthBarWidth, HealthBarHeight);
		_healthBar.MinValue = 0;
		_healthBar.MaxValue = MaxHealth;
		_healthBar.Value = _currentHealth;
		_healthBar.ShowPercentage = false;
		
		// Center the control node within its Node2D parent
		_healthBar.Position = new Vector2(-HealthBarWidth / 2, 0);

		// --- Custom Styling for Red Bar ---

		// 3. Background Style (The empty part of the bar)
		StyleBoxFlat backgroundStyle = new StyleBoxFlat();
		backgroundStyle.SetBgColor(new Color(0.15f, 0.15f, 0.15f)); // Dark Grey
		
		// Fix for C# binding issue: Explicitly casting the integer indices to the required Godot.Corner enum type.
		backgroundStyle.SetCornerRadius((Godot.Corner)0, 2); // TopLeft
		backgroundStyle.SetCornerRadius((Godot.Corner)1, 2); // TopRight
		backgroundStyle.SetCornerRadius((Godot.Corner)2, 2); // BottomRight
		backgroundStyle.SetCornerRadius((Godot.Corner)3, 2); // BottomLeft
		
		// Apply the background style
		_healthBar.AddThemeStyleboxOverride("background", backgroundStyle);

		// 4. Fill Style (The health progress part - Red)
		StyleBoxFlat fillStyle = new StyleBoxFlat();
		fillStyle.SetBgColor(Colors.Red); // Set the color to Red
		
		// Fix for C# binding issue: Explicitly casting the integer indices to the required Godot.Corner enum type.
		fillStyle.SetCornerRadius((Godot.Corner)0, 2); // TopLeft
		fillStyle.SetCornerRadius((Godot.Corner)1, 2); // TopRight
		fillStyle.SetCornerRadius((Godot.Corner)2, 2); // BottomRight
		fillStyle.SetCornerRadius((Godot.Corner)3, 2); // BottomLeft
		
		// Apply the fill style
		_healthBar.AddThemeStyleboxOverride("fill", fillStyle);
		
		// ------------------------------------
		
		// Start hidden, visibility is managed by TakeDamage and the timer
		_healthBar.Visible = false;

		_healthBarContainer.AddChild(_healthBar);
	}

	public void TakeDamage(int dmg)
	{
		_currentHealth -= dmg;
		_currentHealth = Mathf.Clamp(_currentHealth, 0, MaxHealth);
		
		// --- Health Bar Update and Timer Reset ---
		if (_healthBar != null)
		{
			_healthBar.Value = _currentHealth;
			
			// 1. Make the bar visible immediately
			_healthBar.Visible = true; 

			// 2. Reset and start the timer (resets the 3.0 second countdown)
			_healthBarVisibleTimer.Stop();
			// Only start the timer if the enemy is NOT dead
			if (_currentHealth > 0)
			{
				_healthBarVisibleTimer.Start();
			}
		}
		// -----------------------------------------

		// ★ Call the damage flash effect
		FlashDamageEffect();

		if (_currentHealth <= 0)
			Die();
	}
	
	/// <summary>
	/// Hides the health bar when the visibility timer runs out.
	/// </summary>
	private void HideHealthBar()
	{
		if (_healthBar != null)
		{
			// Only hide if the enemy is not at full health (though damage shouldn't be taken 
			// if health is full, this acts as a final safety check if we were to heal the enemy)
			if (_currentHealth < MaxHealth)
			{
				_healthBar.Visible = false;
			}
		}
	}
	
	/// <summary>
	/// Creates a visual flash effect (red tint) on the enemy's sprite when damaged.
	/// </summary>
	private void FlashDamageEffect()
	{
		if (_sprite == null) return;

		// Kill any existing tween to ensure the enemy can flash immediately on a new hit
		Tween oldTween = _sprite.GetChildCount() > 0 ? _sprite.GetChild<Tween>(0) : null;
		if (oldTween != null)
		{
			oldTween.Kill();
		}
		
		// 1. Set the sprite instantly to a hurt color (Red tint with slight transparency)
		Color hurtColor = new Color(1.0f, 0.2f, 0.2f, 0.8f);
		_sprite.Modulate = hurtColor;

		// 2. Create a Tween to handle the transition back to normal
		Tween tween = CreateTween();
		
		// 3. Smoothly fade back to the original color (Colors.White for no tint).
		tween.TweenProperty(_sprite, "modulate", Colors.White, 0.3f) 
			.SetTrans(Tween.TransitionType.Linear)
			.SetEase(Tween.EaseType.Out);
	}

	private void FindPlayer()
	{
		_player = GetTree().GetNodesInGroup("player").FirstOrDefault() as CharacterNode;
	}

	public override void _PhysicsProcess(double delta)
	{
		_dt = (float)delta;
		_attackCooldownTimer -= _dt;

		if (_player == null || !IsInstanceValid(_player))
			FindPlayer();

		Vector2 velocity = Vector2.Zero;

		if (_player != null && IsInstanceValid(_player))
		{
			Vector2 toPlayer = _player.GlobalPosition - GlobalPosition;
			float distance = toPlayer.Length();

			// ATTACK STATE
			if (distance <= AttackRange)
			{
				if (!_isAttacking)
					StartAttackSequence(toPlayer.Normalized());

				if (_isAttacking)
				{
					velocity = Vector2.Zero;
				}
				else
				{
					// If not attacking, move into range to ensure the attack connects
					velocity = toPlayer.Normalized() * Speed; 
				}
			}
			// CHASE STATE
			else if (distance <= DetectionRadius)
			{
				velocity = toPlayer.Normalized() * Speed;
				_wanderChangeDelay = 1f;
			}
			// WANDER
			else
			{
				velocity = GetWanderVelocity();
			}
		}
		else
		{
			velocity = GetWanderVelocity();
		}

		if (!_isAttacking)
		{
			Velocity = velocity;
			MoveAndSlide();

			bool moving = Velocity.LengthSquared() > 0.01f;
			if (moving)
				_lastDirection = Velocity.Normalized();

			UpdateSpriteOrientation(
				moving ? Velocity.Normalized() : _lastDirection,
				moving
			);
		}
		else
		{
			Velocity = Vector2.Zero;
			MoveAndSlide();
		}
	}

	private void UpdateSpriteOrientation(Vector2 direction, bool isMoving)
	{
		if (_isAttacking) return;

		string baseAnim = isMoving ? "walk" : "idle";
		string prefix = "";

		float absX = Mathf.Abs(direction.X);
		float absY = Mathf.Abs(direction.Y);

		// Logic for diagonal/vertical animations
		if (absY > absX + VerticalDominanceBias)
		{
			_sprite.FlipH = false;
			prefix = (direction.Y < 0) ? "top_angle_" : "bottom_angle_";
		}
		else
		{
			_sprite.FlipH = direction.X < 0;
		}

		PlayAnim(prefix + baseAnim);
	}

	private Vector2 GetWanderVelocity()
	{
		_wanderChangeDelay -= _dt;

		// Wall Avoidance Logic
		if (_rayFwd != null && _rayLeft != null && _rayRight != null)
		{
			_rayFwd.Rotation = _wanderAngle;
			_rayLeft.Rotation = _wanderAngle - WallAvoidanceAngle;
			_rayRight.Rotation = _wanderAngle + WallAvoidanceAngle;
			
			_rayFwd.ForceRaycastUpdate();
			_rayLeft.ForceRaycastUpdate();
			_rayRight.ForceRaycastUpdate();
			
			if (_rayFwd.IsColliding() || _rayLeft.IsColliding() || _rayRight.IsColliding())
			{
				bool leftBlocked = _rayLeft.IsColliding();
				bool rightBlocked = _rayRight.IsColliding();

				if (leftBlocked && !rightBlocked)
				{
					_wanderAngle += WallAvoidanceAngle; 
				}
				else if (rightBlocked && !leftBlocked)
				{
					_wanderAngle -= WallAvoidanceAngle; 
				}
				else 
				{
					// Back up and choose a random direction
					if (_rng.NextDouble() < 0.5)
						_wanderAngle += WallAvoidanceAngle; 
					else
						_wanderAngle -= WallAvoidanceAngle;
				}
				
				_wanderChangeDelay = 0.5f; 
			}
		}

		// Random Wander change logic
		if (_wanderChangeDelay <= 0f)
		{
			float randomShift = (float)(_rng.NextDouble() * 0.5 - 0.25);
			_wanderAngle += randomShift;
			_wanderChangeDelay = 1f + (float)_rng.NextDouble() * 2f;
		}

		Vector2 dir = new Vector2(Mathf.Cos(_wanderAngle), Mathf.Sin(_wanderAngle));
		return dir.Normalized() * Speed * WanderSpeedMultiplier;
	}

	private void StartAttackSequence(Vector2 directionToPlayer)
	{
		if (_attackCooldownTimer > 0f) return;

		_isAttacking = true;
		_attackCooldownTimer = AttackCooldown;

		if (_sprite != null)
			_sprite.FlipH = directionToPlayer.X < 0;

		PlayAnim(AttackAnimationName);
		
		// ★ ACCURACY FIX: Start the timer to apply damage at the point of impact
		_damageTimer.Start();
	}

	// ★ New method to handle damage application at the precise moment of impact
	private void ApplyDamage()
	{
		// This runs after the AttackHitDelay (0.3s) simulating the swing time.
		if (_player != null && IsInstanceValid(_player))
		{
			float dist = (_player.GlobalPosition - GlobalPosition).Length();
			
			// Check if the player is still within attack range at the hit moment
			if (dist <= AttackRange) 
			{
				_player.TakeDamage(AttackDamage);
			}
		}
	}

	private void OnAttackAnimationFinished()
	{
		if (_sprite.Animation == AttackAnimationName)
		{
			// ★ ACCURACY FIX: Damage check is now in ApplyDamage(), only reset state here
			_isAttacking = false;
		}
	}

	private void Die()
	{
		if (_sprite != null &&
			_sprite.IsConnected(
				AnimatedSprite2D.SignalName.AnimationFinished,
				new Callable(this, nameof(OnAttackAnimationFinished))
			))
		{
			_sprite.Disconnect(
				AnimatedSprite2D.SignalName.AnimationFinished,
				new Callable(this, nameof(OnAttackAnimationFinished))
			);
		}

		if (_playerSearchTimer != null)
		{
			_playerSearchTimer.Stop();
			_playerSearchTimer.QueueFree();
		}

		// Clean up the new damage timer
		if (_damageTimer != null)
		{
			_damageTimer.Stop();
			_damageTimer.QueueFree();
		}
		
		// Clean up the health bar visibility timer
		if (_healthBarVisibleTimer != null)
		{
			_healthBarVisibleTimer.Stop();
			_healthBarVisibleTimer.QueueFree();
		}

		// Reset modulation when dying
		if (_sprite != null)
		{
			_sprite.Modulate = Colors.White;
		}
		
		// Clean up the health bar container
		if (_healthBarContainer != null)
		{
			_healthBarContainer.QueueFree();
		}

		QueueFree();
	}

	private void PlayAnim(string anim)
	{
		if (_sprite == null) return;

		if (anim == AttackAnimationName)
		{
			if (_sprite.Animation != anim)
			{
				_sprite.Play(anim, customSpeed: 1.0f, fromEnd: false);
				_sprite.Frame = 0;
			}
			return;
		}

		if (_isAttacking) return;

		string target = anim;

		// Fallback logic for animation names (e.g., if "top_angle_walk" is missing, use "walk")
		if (!_sprite.SpriteFrames.HasAnimation(target))
		{
			target = anim.Contains("walk") ? "walk" :
					 anim.Contains("idle") ? "idle" : target;

			if (!_sprite.SpriteFrames.HasAnimation(target))
				return;
		}

		if (_sprite.Animation != target)
			_sprite.Play(target);
	}

	private void _on_attack_area_body_entered(Node2D body) {}
}
