using Godot;
using System;
using System.Linq;

public partial class Brownrat : CharacterBody2D
{
	[Export] public float Speed { get; set; } = 130f;
	[Export] public int AttackDamage { get; set; } = 2;
	[Export] public float AttackCooldown { get; set; } = 1.0f;
	[Export] public float AttackRange { get; set; } = 500f;
	[Export] public int MaxHealth { get; set; } = 80;
	[Export] public float DetectionRadius { get; set; } = 500f;
	[Export] public float WanderSpeedMultiplier { get; set; } = 0.20f;
	
	[Export] public float WallDetectionDistance { get; set; } = 50f;
	private const float WallAvoidanceAngle = Mathf.Pi / 20f;

	[Export] public string AttackAnimationName { get; set; } = "attack";
	[Export] public PackedScene ProjectileScene { get; set; }
	
	// New export property for how long the health bar stays visible after being hit
	[Export] public float HealthBarVisibilityTime { get; set; } = 3.0f; 

	private AnimatedSprite2D _sprite;
	private Random _rng = new Random();
	
	private RayCast2D _rayFwd;
	private RayCast2D _rayLeft;
	private RayCast2D _rayRight;
	
	private float _wanderAngle = 0f;
	private float _wanderChangeDelay = 0f;

	private int _currentHealth;
	private float _attackCooldownTimer = 0f;

	private bool _isAttacking = false;

	private CharacterNode _player; // Uses CharacterNode
	private float _dt;

	private Timer _playerSearchTimer;
	private Timer _healthBarVisibleTimer; // Timer to hide the health bar

	private Vector2 _lastDirection = Vector2.Down;

	private const float VerticalDominanceBias = 0.15f;
	
	// --- Health Bar Properties ---
	private Node2D _healthBarContainer;
	private ProgressBar _healthBar;
	private const float HealthBarHeightOffset = -35f; 
	private const float HealthBarWidth = 70f;
	private const float HealthBarHeight = 8f;
	// ---------------------------

	public override void _Ready()
	{
		AddToGroup("enemy");

		_sprite = GetNodeOrNull<AnimatedSprite2D>("AnimatedSprite2D");

		_rayFwd = GetNodeOrNull<RayCast2D>("RayCastFwd");
		_rayLeft = GetNodeOrNull<RayCast2D>("RayCastLeft");
		_rayRight = GetNodeOrNull<RayCast2D>("RayCastRight");
		
		if (_rayFwd != null) _rayFwd.TargetPosition = Vector2.Right * WallDetectionDistance;
		if (_rayLeft != null) _rayLeft.TargetPosition = Vector2.Right.Rotated(-WallAvoidanceAngle / 2) * WallDetectionDistance;
		if (_rayRight != null) _rayRight.TargetPosition = Vector2.Right.Rotated(WallAvoidanceAngle / 2) * WallDetectionDistance;

		if (_sprite != null)
		{
			_sprite.Connect(
				AnimatedSprite2D.SignalName.AnimationFinished,
				new Callable(this, nameof(OnAttackAnimationFinished))
			);
		}

		_currentHealth = MaxHealth;
		
		// --- Health Bar Setup ---
		CreateHealthBar();
		// ----------------------
		
		// --- Health Bar Visibility Timer Setup ---
		_healthBarVisibleTimer = new Timer();
		AddChild(_healthBarVisibleTimer);
		_healthBarVisibleTimer.OneShot = true;
		_healthBarVisibleTimer.WaitTime = HealthBarVisibilityTime;
		// Connect the timeout signal to our new method
		_healthBarVisibleTimer.Timeout += HideHealthBar;
		// -----------------------------------------

		_wanderAngle = (float)(_rng.NextDouble() * Math.PI * 2);
		_wanderChangeDelay = 1f + (float)_rng.NextDouble() * 2f;

		_playerSearchTimer = new Timer();
		AddChild(_playerSearchTimer);
		_playerSearchTimer.WaitTime = 2.0f;
		_playerSearchTimer.Timeout += FindPlayer;
		_playerSearchTimer.Start();

		FindPlayer();
	}
	
	/// <summary>
	/// Creates and initializes the visual health bar above the enemy.
	/// </summary>
	private void CreateHealthBar()
	{
		// 1. Container for positioning (Node2D)
		_healthBarContainer = new Node2D();
		_healthBarContainer.Name = "HealthBarContainer";
		_healthBarContainer.Position = new Vector2(0, HealthBarHeightOffset);
		AddChild(_healthBarContainer);

		// 2. The Health Bar itself (ProgressBar)
		_healthBar = new ProgressBar();
		_healthBar.Name = "HealthBar";
		
		_healthBar.Size = new Vector2(HealthBarWidth, HealthBarHeight);
		_healthBar.MinValue = 0;
		_healthBar.MaxValue = MaxHealth;
		_healthBar.Value = _currentHealth;
		_healthBar.ShowPercentage = false;
		
		// Center the control node within its Node2D parent
		_healthBar.Position = new Vector2(-HealthBarWidth / 2, 0);

		// --- Custom Styling ---

		// 3. Background Style (Dark Grey)
		StyleBoxFlat backgroundStyle = new StyleBoxFlat();
		backgroundStyle.SetBgColor(new Color(0.15f, 0.15f, 0.15f));
		backgroundStyle.SetCornerRadius((Godot.Corner)0, 2); 
		backgroundStyle.SetCornerRadius((Godot.Corner)1, 2);
		backgroundStyle.SetCornerRadius((Godot.Corner)2, 2);
		backgroundStyle.SetCornerRadius((Godot.Corner)3, 2);
		_healthBar.AddThemeStyleboxOverride("background", backgroundStyle);

		// 4. Fill Style (Red)
		StyleBoxFlat fillStyle = new StyleBoxFlat();
		fillStyle.SetBgColor(Colors.Red);
		fillStyle.SetCornerRadius((Godot.Corner)0, 2);
		fillStyle.SetCornerRadius((Godot.Corner)1, 2);
		fillStyle.SetCornerRadius((Godot.Corner)2, 2);
		fillStyle.SetCornerRadius((Godot.Corner)3, 2);
		_healthBar.AddThemeStyleboxOverride("fill", fillStyle);
		
		// ----------------------
		
		// Start hidden, visibility is managed by TakeDamage and the timer
		_healthBar.Visible = false;

		_healthBarContainer.AddChild(_healthBar);
	}

	public void TakeDamage(int dmg)
	{
		_currentHealth -= dmg;
		_currentHealth = Mathf.Clamp(_currentHealth, 0, MaxHealth);
		
		// --- Health Bar Update and Timer Reset ---
		if (_healthBar != null)
		{
			_healthBar.Value = _currentHealth;
			
			// 1. Make the bar visible immediately
			_healthBar.Visible = true; 

			// 2. Reset and start the timer (resets the 3.0 second countdown)
			_healthBarVisibleTimer.Stop();
			// Only start the timer if the enemy is NOT dead
			if (_currentHealth > 0)
			{
				_healthBarVisibleTimer.Start();
			}
		}
		// -----------------------------------------
		
		FlashDamageEffect();

		if (_currentHealth <= 0)
			Die();
	}
	
	/// <summary>
	/// Hides the health bar when the visibility timer runs out.
	/// </summary>
	private void HideHealthBar()
	{
		if (_healthBar != null)
		{
			_healthBar.Visible = false;
		}
	}
	
	private void FlashDamageEffect()
	{
		if (_sprite == null) return;

		Tween oldTween = GetNodeOrNull<Tween>("Tween");
		if (oldTween != null)
		{
			oldTween.Kill();
		}
		
		Color hurtColor = new Color(1.0f, 0.2f, 0.2f, 0.8f);
		_sprite.Modulate = hurtColor;

		Tween tween = CreateTween();
		
		tween.TweenProperty(_sprite, "modulate", Colors.White, 0.3f)
			.SetTrans(Tween.TransitionType.Linear)
			.SetEase(Tween.EaseType.Out);
	}

	private void FindPlayer()
	{
		_player = GetTree().GetNodesInGroup("player").FirstOrDefault() as CharacterNode;
	}

	public override void _PhysicsProcess(double delta)
	{
		_dt = (float)delta;
		_attackCooldownTimer -= _dt;

		if (_player == null || !IsInstanceValid(_player))
			FindPlayer();

		Vector2 velocity = Vector2.Zero;

		if (_player != null && IsInstanceValid(_player))
		{
			Vector2 toPlayer = _player.GlobalPosition - GlobalPosition;
			float distance = toPlayer.Length();

			if (distance <= AttackRange)
			{
				if (!_isAttacking)
					StartAttackSequence(toPlayer.Normalized());
			}
			else if (distance <= DetectionRadius)
			{
				velocity = toPlayer.Normalized() * Speed;
				_wanderChangeDelay = 1f;
			}
			else
			{
				velocity = GetWanderVelocity();
			}
		}
		else
		{
			velocity = GetWanderVelocity();
		}

		if (!_isAttacking)
		{
			Velocity = velocity;
			MoveAndSlide();

			bool moving = Velocity.LengthSquared() > 0.01f;
			if (moving)
				_lastDirection = Velocity.Normalized();

			UpdateSpriteOrientation(
				moving ? Velocity.Normalized() : _lastDirection,
				moving
			);
		}
		else
		{
			Velocity = Vector2.Zero;
			MoveAndSlide();
		}
	}

	private void UpdateSpriteOrientation(Vector2 direction, bool isMoving)
	{
		if (_isAttacking) return;

		string baseAnim = isMoving ? "walk" : "idle";
		string prefix = "";

		float absX = Mathf.Abs(direction.X);
		float absY = Mathf.Abs(direction.Y);

		if (absY > absX + VerticalDominanceBias)
		{
			_sprite.FlipH = false;
			prefix = (direction.Y < 0) ? "top_angle_" : "bottom_angle_";
		}
		else
		{
			_sprite.FlipH = direction.X < 0;
		}

		PlayAnim(prefix + baseAnim);
	}

	private Vector2 GetWanderVelocity()
	{
		_wanderChangeDelay -= _dt;

		if (_rayFwd != null && _rayLeft != null && _rayRight != null)
		{
			_rayFwd.Rotation = _wanderAngle;
			_rayLeft.Rotation = _wanderAngle - WallAvoidanceAngle;
			_rayRight.Rotation = _wanderAngle + WallAvoidanceAngle;
			
			_rayFwd.ForceRaycastUpdate();
			_rayLeft.ForceRaycastUpdate();
			_rayRight.ForceRaycastUpdate();
			
			if (_rayFwd.IsColliding() || _rayLeft.IsColliding() || _rayRight.IsColliding())
			{
				bool leftBlocked = _rayLeft.IsColliding();
				bool rightBlocked = _rayRight.IsColliding();

				if (leftBlocked && !rightBlocked)
				{
					_wanderAngle += WallAvoidanceAngle;
				}
				else if (rightBlocked && !leftBlocked)
				{
					_wanderAngle -= WallAvoidanceAngle;
				}
				else
				{
					if (_rng.NextDouble() < 0.5)
						_wanderAngle += WallAvoidanceAngle;
					else
						_wanderAngle -= WallAvoidanceAngle;
				}
				
				_wanderChangeDelay = 0.5f;
			}
		}

		if (_wanderChangeDelay <= 0f)
		{
			float randomShift = (float)(_rng.NextDouble() * 0.5 - 0.25);
			_wanderAngle += randomShift;
			_wanderChangeDelay = 1f + (float)_rng.NextDouble() * 2f;
		}

		Vector2 dir = new Vector2(Mathf.Cos(_wanderAngle), Mathf.Sin(_wanderAngle));
		return dir.Normalized() * Speed * WanderSpeedMultiplier;
	}

	private void StartAttackSequence(Vector2 directionToPlayer)
	{
		if (_attackCooldownTimer > 0f) return;
		if (ProjectileScene == null) return;

		_isAttacking = true;
		_attackCooldownTimer = AttackCooldown;

		if (_sprite != null)
			_sprite.FlipH = directionToPlayer.X < 0;

		PlayAnim(AttackAnimationName);
		
		ShootProjectile(directionToPlayer);
	}
	
	// Updated to accept the direction
	private void ShootProjectile(Vector2 directionToPlayer)
	{
		if (ProjectileScene == null) return;

		// Calculate the rotation angle (in radians)
		float rotationAngle = directionToPlayer.Angle();

		// Fire from the rat's GlobalPosition, using the calculated angle
		FireProjectileFrom(GlobalPosition, rotationAngle);
	}

	// Updated to accept rotation (Position now uses the rat's center)
	private void FireProjectileFrom(Vector2 startPosition, float initialRotation)
	{
		// IMPORTANT: Ensure RatProjectile.cs exists and handles the projectile movement/collision.
		RatProjectile projectile = ProjectileScene.Instantiate<RatProjectile>();

		projectile.GlobalPosition = startPosition;
		projectile.Damage = AttackDamage;
		projectile.Rotation = initialRotation; // Set the projectile's starting rotation

		GetTree().Root.AddChild(projectile);
	}

	private void OnAttackAnimationFinished()
	{
		if (_sprite.Animation == AttackAnimationName)
		{
			_isAttacking = false;
		}
	}

	private void Die()
	{
		if (_sprite != null &&
			_sprite.IsConnected(
				AnimatedSprite2D.SignalName.AnimationFinished,
				new Callable(this, nameof(OnAttackAnimationFinished))
			))
		{
			_sprite.Disconnect(
				AnimatedSprite2D.SignalName.AnimationFinished,
				new Callable(this, nameof(OnAttackAnimationFinished))
			);
		}

		if (_playerSearchTimer != null)
		{
			_playerSearchTimer.Stop();
			_playerSearchTimer.QueueFree();
		}

		// Clean up the health bar visibility timer
		if (_healthBarVisibleTimer != null)
		{
			_healthBarVisibleTimer.Stop();
			_healthBarVisibleTimer.QueueFree();
		}

		if (_sprite != null)
		{
			_sprite.Modulate = Colors.White;
		}
		
		// Clean up the health bar container
		if (_healthBarContainer != null)
		{
			_healthBarContainer.QueueFree();
		}

		QueueFree();
	}

	private void PlayAnim(string anim)
	{
		if (_sprite == null) return;

		if (anim == AttackAnimationName)
		{
			if (_sprite.Animation != anim)
			{
				_sprite.Play(anim, customSpeed: 1.0f, fromEnd: false);
				_sprite.Frame = 0;
			}
			return;
		}

		if (_isAttacking) return;

		string target = anim;

		if (!_sprite.SpriteFrames.HasAnimation(target))
		{
			target = anim.Contains("walk") ? "walk" :
					 anim.Contains("idle") ? "idle" : target;

			if (!_sprite.SpriteFrames.HasAnimation(target))
				return;
		}

		if (_sprite.Animation != target)
			_sprite.Play(target);
	}

	private void _on_attack_area_body_entered(Node2D body) {}
}
