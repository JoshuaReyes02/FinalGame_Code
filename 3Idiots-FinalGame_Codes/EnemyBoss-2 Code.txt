using Godot;
using System;
using System.Linq;
using System.Collections.Generic;

public partial class Enemyboss2 : CharacterBody2D
{
	[Signal]
	public delegate void KilledEventHandler();

	[Export] public float Speed { get; set; } = 300f;
	[Export] public int AttackDamage { get; set; } = 2;
	[Export] public float AttackCooldown { get; set; } = 2f;
	[Export] public float AttackRange { get; set; } = 180f;
	[Export] public int MaxHealth { get; set; } = 3000;
	[Export] public float DetectionRadius { get; set; } = 900f;
	[Export] public float WanderSpeedMultiplier { get; set; } = 0.60f;
	
	[Export] public float WallDetectionDistance { get; set; } = 150f;
	private const float WallAvoidanceAngle = Mathf.Pi / 20f;
	private const float AttackHitDelay = 0.3f;

	// --- Offensive Dash Parameters ---
	[Export] public float DashSpeed { get; set; } = 1200f; 
	[Export] public float DashDuration { get; set; } = 0.25f; 
	[Export] public float DashCooldownTime { get; set; } = 5.0f; 

	// --- Defensive Evasion Parameters ---
	[Export] public float EvasionSpeed { get; set; } = 900f;
	[Export] public float EvasionDuration { get; set; } = 0.15f; 
	[Export] public float EvasionActionCooldown { get; set; } = 5.0f;
	[Export] public float BulletDetectionRadius { get; set; } = 150f;

	// Constants for the damage flash effect
	private static readonly Color DAMAGE_FLASH_COLOR = new Color(1.0f, 0.2f, 0.2f);
	private const float DAMAGE_FLASH_DURATION = 0.15f;

	// ★ FIRE PARTICLE CONSTANTS (HUGE COVERAGE & PHYSICS UPDATED) ★
	private const float PARTICLE_RATE = 0.015f;
	private const float PARTICLE_LIFETIME = 1.2f;
	private const float PARTICLE_SPEED_Y = -100f;
	private const float PARTICLE_SPREAD = 120f;
	private const float PARTICLE_SIZE_MIN = 25f;
	private const float PARTICLE_SIZE_MAX = 40f;
	private const float PARTICLE_DRAG = 0.5f; // New constant: How much enemy velocity influences fire velocity
	// ------------------------------------

	// --- Animation Export Properties ---
	[Export] public string AttackAnimationName { get; set; } = "attack";
	[Export] public string AttackAnimationNameLeft { get; set; } = "attack_left"; 
	[Export] public string AttackAnimationNameRight { get; set; } = "attack_right";
	[Export] public string AttackAnimationNameBottom { get; set; } = "attack_bottom";
	[Export] public string AttackAnimationNameTop { get; set; } = "attack_top";
	[Export] public float HealthBarVisibilityTime { get; set; } = 3.0f; 

	private AnimatedSprite2D _sprite;
	private Random _rng = new Random();
	
	private RayCast2D _rayFwd;
	private RayCast2D _rayLeft;
	private RayCast2D _rayRight;
	
	private Timer _damageTimer; 
	private Timer _flashTimer;   
	private Timer _healthBarVisibleTimer;

	// --- Dash State ---
	private Timer _dashCooldownTimer;
	private Timer _dashDurationTimer;
	private Vector2 _dashDirection = Vector2.Zero;
	private bool _isDashing = false;

	// --- Evasion State ---
	private Timer _evasionActionTimer;
	private Timer _evasionDurationTimer;
	private Vector2 _evasionDirection = Vector2.Zero;
	private bool _isEvading = false;
	
	// ★ FIRE PARTICLE STATE (CPU Particle System) ★
	private List<Vector2> _particlePositions = new List<Vector2>();
	private List<Vector2> _particleVelocities = new List<Vector2>();
	private List<float> _particleLifetimes = new List<float>();
	private List<float> _particleMaxLifetimes = new List<float>();
	private List<float> _particleSizes = new List<float>();
	private List<Color> _particleColors = new List<Color>();
	
	private float _particleTimer = 0f;
	// ---------------------------------

	private float _wanderAngle = 0f;
	private float _wanderChangeDelay = 0f;

	private int _currentHealth;
	private float _attackCooldownTimer = 0f;

	private bool _isAttacking = false;

	private CharacterNode _player;
	private float _dt;

	private Timer _playerSearchTimer;

	private Vector2 _lastDirection = Vector2.Down;

	private const float VerticalDominanceBias = 0.15f;
	
	private Node2D _healthBarContainer;
	private ProgressBar _healthBar;
	private const float HealthBarHeightOffset = -70f; 
	private const float HealthBarWidth = 250f; 
	private const float HealthBarHeight = 14f;


	public override void _Ready()
	{
		AddToGroup("enemy");

		_sprite = GetNodeOrNull<AnimatedSprite2D>("AnimatedSprite2D");
		
		_rayFwd = GetNodeOrNull<RayCast2D>("RayCastFwd");
		_rayLeft = GetNodeOrNull<RayCast2D>("RayCastLeft");
		_rayRight = GetNodeOrNull<RayCast2D>("RayCastRight");
		
		// Setup Timers (Damage & Flash)
		_damageTimer = new Timer();
		AddChild(_damageTimer);
		_damageTimer.OneShot = true;
		_damageTimer.WaitTime = AttackHitDelay;
		_damageTimer.Timeout += ApplyDamage;

		_flashTimer = new Timer();
		AddChild(_flashTimer);
		_flashTimer.OneShot = true;
		_flashTimer.WaitTime = DAMAGE_FLASH_DURATION;
		_flashTimer.Timeout += ResetFlashColor; 
		
		// --- Offensive Dash Timers Setup ---
		_dashCooldownTimer = new Timer();
		AddChild(_dashCooldownTimer);
		_dashCooldownTimer.WaitTime = DashCooldownTime;
		_dashCooldownTimer.Autostart = true;
		_dashCooldownTimer.Timeout += OnDashCooldownTimeout;

		_dashDurationTimer = new Timer();
		AddChild(_dashDurationTimer);
		_dashDurationTimer.OneShot = true;
		_dashDurationTimer.WaitTime = DashDuration;
		_dashDurationTimer.Timeout += OnDashDurationTimeout;
		
		// --- Defensive Evasion Timers Setup ---
		_evasionActionTimer = new Timer();
		AddChild(_evasionActionTimer);
		_evasionActionTimer.WaitTime = EvasionActionCooldown;
		_evasionActionTimer.Autostart = true;
		_evasionActionTimer.Timeout += OnEvasionActionTimeout;

		_evasionDurationTimer = new Timer();
		AddChild(_evasionDurationTimer);
		_evasionDurationTimer.OneShot = true;
		_evasionDurationTimer.WaitTime = EvasionDuration;
		_evasionDurationTimer.Timeout += OnEvasionDurationTimeout;
		
		// Initialize RayCast target positions
		if (_rayFwd != null) _rayFwd.TargetPosition = Vector2.Right * WallDetectionDistance;
		if (_rayLeft != null) _rayLeft.TargetPosition = Vector2.Right.Rotated(-WallAvoidanceAngle / 2) * WallDetectionDistance;
		if (_rayRight != null) _rayRight.TargetPosition = Vector2.Right.Rotated(WallAvoidanceAngle / 2) * WallDetectionDistance;

		if (_sprite != null)
		{
			_sprite.Connect(
				AnimatedSprite2D.SignalName.AnimationFinished,
				new Callable(this, nameof(OnAttackAnimationFinished))
			);
			_sprite.SelfModulate = Colors.White; 
		}

		_currentHealth = MaxHealth;
		
		// Health Bar Setup
		CreateHealthBar();
		
		_healthBarVisibleTimer = new Timer();
		AddChild(_healthBarVisibleTimer);
		_healthBarVisibleTimer.OneShot = true;
		_healthBarVisibleTimer.WaitTime = HealthBarVisibilityTime;
		_healthBarVisibleTimer.Timeout += HideHealthBar;

		_wanderAngle = (float)(_rng.NextDouble() * Math.PI * 2);
		_wanderChangeDelay = 1f + (float)_rng.NextDouble() * 2f;

		_playerSearchTimer = new Timer();
		AddChild(_playerSearchTimer);
		_playerSearchTimer.WaitTime = 2.0f;
		_playerSearchTimer.Timeout += FindPlayer;
		_playerSearchTimer.Start();

		FindPlayer();
	}
	
	// --- PARTICLE LOGIC (UPDATED) ---
	
	private void SpawnFireParticle()
	{
		// 1. Randomize initial position around the boss's center (0, 0 local)
		float offsetX = (float)_rng.NextDouble() * PARTICLE_SPREAD - (PARTICLE_SPREAD / 2f);
		float offsetY = (float)_rng.NextDouble() * PARTICLE_SPREAD - (PARTICLE_SPREAD / 2f);
		_particlePositions.Add(new Vector2(offsetX, offsetY));
		
		// 2. Randomize size and lifetime
		float size = (float)_rng.NextDouble() * (PARTICLE_SIZE_MAX - PARTICLE_SIZE_MIN) + PARTICLE_SIZE_MIN;
		float maxLife = PARTICLE_LIFETIME + (float)_rng.NextDouble() * 0.1f;
		
		_particleSizes.Add(size);
		_particleLifetimes.Add(maxLife);
		_particleMaxLifetimes.Add(maxLife);

		// 3. Randomize color (orange/red)
		Color startColor = (float)_rng.NextDouble() < 0.5
			? new Color(1.0f, 0.5f, 0.0f, 0.7f) // Orange
			: new Color(1.0f, 0.0f, 0.0f, 0.7f); // Red
		_particleColors.Add(startColor);

		// 4. Calculate initial velocity (upward with slight horizontal variance)
		Vector2 wind = new Vector2(
			(float)_rng.NextDouble() * 50f - 25f,
			PARTICLE_SPEED_Y
		);
		
		// 5. Apply drag/momentum from the enemy's current movement
		Vector2 initialVelocity = wind + Velocity * PARTICLE_DRAG; 
		
		_particleVelocities.Add(initialVelocity);
	}
	
	public override void _Draw()
	{
		for (int i = 0; i < _particlePositions.Count; i++)
		{
			float ratio = _particleLifetimes[i] / _particleMaxLifetimes[i];
			
			float alpha = ratio * ratio * _particleColors[i].A; 
			
			float currentSize = _particleSizes[i] * ratio;
			
			Color currentColor = new Color(
				_particleColors[i].R, 
				_particleColors[i].G, 
				_particleColors[i].B, 
				alpha
			);
			
			DrawCircle(_particlePositions[i], currentSize / 2f, currentColor);
		}
	}

	private void UpdateParticles(float delta)
	{
		for (int i = _particleLifetimes.Count - 1; i >= 0; i--)
		{
			// 1. Update Position
			_particlePositions[i] += _particleVelocities[i] * delta;
			
			// 2. Update Lifetime
			_particleLifetimes[i] -= delta;
			
			// 3. Check for Expiry
			if (_particleLifetimes[i] <= 0)
			{
				_particlePositions.RemoveAt(i);
				_particleVelocities.RemoveAt(i);
				_particleLifetimes.RemoveAt(i);
				_particleMaxLifetimes.RemoveAt(i);
				_particleSizes.RemoveAt(i);
				_particleColors.RemoveAt(i);
			}
		}
		
		QueueRedraw();
	}
	
	// --- END PARTICLE LOGIC ---
	
	private void CreateHealthBar()
	{
		_healthBarContainer = new Node2D();
		_healthBarContainer.Name = "HealthBarContainer";
		_healthBarContainer.Position = new Vector2(0, HealthBarHeightOffset);
		AddChild(_healthBarContainer);

		_healthBar = new ProgressBar();
		_healthBar.Name = "HealthBar";
		_healthBar.Size = new Vector2(HealthBarWidth, HealthBarHeight);
		_healthBar.MinValue = 0;
		_healthBar.MaxValue = MaxHealth;
		_healthBar.Value = _currentHealth;
		_healthBar.ShowPercentage = false;
		_healthBar.Position = new Vector2(-HealthBarWidth / 2, 0);

		// 1. Background Style (Dark Grey/Black)
		StyleBoxFlat backgroundStyle = new StyleBoxFlat();
		backgroundStyle.SetBgColor(new Color(0.1f, 0.1f, 0.1f)); 
		backgroundStyle.SetCornerRadius((Godot.Corner)0, 3); 
		backgroundStyle.SetCornerRadius((Godot.Corner)1, 3); 
		backgroundStyle.SetCornerRadius((Godot.Corner)2, 3); 
		backgroundStyle.SetCornerRadius((Godot.Corner)3, 3); 
		_healthBar.AddThemeStyleboxOverride("background", backgroundStyle);

		// 2. Fill Style (Dark Red color applied here)
		StyleBoxFlat fillStyle = new StyleBoxFlat();
		fillStyle.SetBgColor(new Color(0.6f, 0.1f, 0.1f)); 
		fillStyle.SetCornerRadius((Godot.Corner)0, 3); 
		fillStyle.SetCornerRadius((Godot.Corner)1, 3); 
		fillStyle.SetCornerRadius((Godot.Corner)2, 3); 
		fillStyle.SetCornerRadius((Godot.Corner)3, 3); 
		_healthBar.AddThemeStyleboxOverride("fill", fillStyle);
		
		_healthBar.Visible = false;
		_healthBarContainer.AddChild(_healthBar);
	}
	
	private void HideHealthBar()
	{
		if (_healthBar != null && _currentHealth < MaxHealth)
		{
			_healthBar.Visible = false;
		}
	}

	private void OnDashCooldownTimeout()
	{
		if (_player != null && IsInstanceValid(_player) && !_isAttacking && !_isEvading)
		{
			_isDashing = true;
			_dashDirection = (_player.GlobalPosition - GlobalPosition).Normalized();
			_dashDurationTimer.Start();
			
			if (_sprite != null) _sprite.Stop(); 
		}
	}

	private void OnDashDurationTimeout()
	{
		_isDashing = false;
		_dashCooldownTimer.Start(); 
	}
	
	private void OnEvasionActionTimeout()
	{
		if (_isAttacking || _isDashing || _isEvading)
		{
			_evasionActionTimer.Start();
			return; 
		}
		
		Node2D closestBullet = null;
		float closestDistSq = BulletDetectionRadius * BulletDetectionRadius;

		foreach (Node node in GetTree().GetNodesInGroup("player_bullet"))
		{
			if (node is Area2D bulletArea) 
			{
				float distSq = GlobalPosition.DistanceSquaredTo(bulletArea.GlobalPosition);
				if (distSq < closestDistSq)
				{
					closestDistSq = distSq;
					closestBullet = bulletArea;
				}
			}
		}

		if (closestBullet != null)
		{
			Vector2 bulletDirection = Vector2.Zero;
			
			if (closestBullet.HasMethod("GetDirection"))
			{
				bulletDirection = (Vector2)closestBullet.Call("GetDirection");
			}

			if (bulletDirection.LengthSquared() > 0)
			{
				Vector2 perpDirection = bulletDirection.Rotated(Mathf.Pi / 2.0f).Normalized();
				
				if (_rng.NextDouble() < 0.5)
				{
					perpDirection = perpDirection.Rotated(Mathf.Pi);
				}
				
				_isEvading = true;
				_evasionDirection = perpDirection;
				_evasionDurationTimer.Start();
				
				if (_sprite != null) _sprite.Stop();
			}
		}

		_evasionActionTimer.Start();
	}

	private void OnEvasionDurationTimeout()
	{
		_isEvading = false;
	}
	
	public void TakeDamage(int dmg)
	{
		if (_sprite != null)
		{
			_sprite.SelfModulate = DAMAGE_FLASH_COLOR;
			_flashTimer.Start();
		}

		_currentHealth -= dmg;
		_currentHealth = Mathf.Clamp(_currentHealth, 0, MaxHealth);
		
		if (_healthBar != null)
		{
			_healthBar.Value = _currentHealth;
			_healthBar.Visible = true; 

			_healthBarVisibleTimer.Stop();
			if (_currentHealth > 0)
			{
				_healthBarVisibleTimer.Start();
			}
		}

		if (_currentHealth <= 0)
			Die();
	}
	
	private void ResetFlashColor()
	{
		if (_sprite != null)
		{
			_sprite.SelfModulate = Colors.White;
		}
	}

	private void FindPlayer()
	{
		_player = GetTree().GetNodesInGroup("player").FirstOrDefault() as CharacterNode;
	}

	public override void _PhysicsProcess(double delta)
	{
		_dt = (float)delta;
		_attackCooldownTimer -= _dt;
		
		// Update and spawn particles
		UpdateParticles(_dt);
		
		_particleTimer -= _dt;
		if (_particleTimer <= 0)
		{
			SpawnFireParticle();
			SpawnFireParticle(); 
			_particleTimer = PARTICLE_RATE;
		}

		if (_player == null || !IsInstanceValid(_player))
			FindPlayer();

		Vector2 velocity = Vector2.Zero;
		
		// Movement/State Logic
		if (_isEvading)
		{
			velocity = _evasionDirection * EvasionSpeed;
		}
		else if (_isDashing)
		{
			velocity = _dashDirection * DashSpeed;
		}
		else if (_player != null && IsInstanceValid(_player))
		{
			Vector2 toPlayer = _player.GlobalPosition - GlobalPosition;
			float distance = toPlayer.Length();

			if (distance <= AttackRange)
			{
				if (!_isAttacking)
					StartAttackSequence(toPlayer.Normalized());

				velocity = Vector2.Zero;
			}
			else if (distance <= DetectionRadius)
			{
				velocity = toPlayer.Normalized() * Speed;
				_wanderChangeDelay = 1f;
			}
			else
			{
				velocity = GetWanderVelocity();
			}
		}
		else
		{
			velocity = GetWanderVelocity();
		}

		// Apply movement and update sprite
		if (!_isAttacking)
		{
			Velocity = velocity;
			MoveAndSlide();

			bool moving = Velocity.LengthSquared() > 0.01f;
			if (moving)
				_lastDirection = Velocity.Normalized();
			
			if (!_isDashing && !_isEvading) 
			{
				UpdateSpriteOrientation(
					moving ? Velocity.Normalized() : _lastDirection,
					moving
				);
			}
		}
		else 
		{
			Velocity = Vector2.Zero;
			MoveAndSlide();
		}
	}
	
	private void UpdateSpriteOrientation(Vector2 direction, bool isMoving)
	{
		if (_isAttacking || _isDashing || _isEvading) return; 

		string baseAnim = isMoving ? "walk" : "idle";
		string prefix = "";

		float absX = Mathf.Abs(direction.X);
		float absY = Mathf.Abs(direction.Y);

		if (absY > absX + VerticalDominanceBias)
		{
			_sprite.FlipH = false;
			prefix = (direction.Y < 0) ? "top_angle_" : "bottom_angle_";
		}
		else
		{
			_sprite.FlipH = direction.X < 0;
		}

		PlayAnim(prefix + baseAnim);
	}

	private Vector2 GetWanderVelocity()
	{
		_wanderChangeDelay -= _dt;

		// Wall Avoidance Logic
		if (_rayFwd != null && _rayLeft != null && _rayRight != null)
		{
			_rayFwd.Rotation = _wanderAngle;
			_rayLeft.Rotation = _wanderAngle - WallAvoidanceAngle;
			_rayRight.Rotation = _wanderAngle + WallAvoidanceAngle;
			
			_rayFwd.ForceRaycastUpdate();
			_rayLeft.ForceRaycastUpdate();
			_rayRight.ForceRaycastUpdate();
			
			if (_rayFwd.IsColliding() || _rayLeft.IsColliding() || _rayRight.IsColliding())
			{
				bool leftBlocked = _rayLeft.IsColliding();
				bool rightBlocked = _rayRight.IsColliding();

				if (leftBlocked && !rightBlocked)
				{
					_wanderAngle += WallAvoidanceAngle; 
				}
				else if (rightBlocked && !leftBlocked)
				{
					_wanderAngle -= WallAvoidanceAngle; 
				}
				else 
				{
					if (_rng.NextDouble() < 0.5)
						_wanderAngle += WallAvoidanceAngle; 
					else
						_wanderAngle -= WallAvoidanceAngle;
				}
				
				_wanderChangeDelay = 0.5f; 
			}
		}

		// Random Wander change logic
		if (_wanderChangeDelay <= 0f)
		{
			float randomShift = (float)(_rng.NextDouble() * 0.5 - 0.25);
			_wanderAngle += randomShift;
			_wanderChangeDelay = 1f + (float)_rng.NextDouble() * 2f;
		}

		Vector2 dir = new Vector2(Mathf.Cos(_wanderAngle), Mathf.Sin(_wanderAngle));
		return dir.Normalized() * Speed * WanderSpeedMultiplier;
	}

	private void StartAttackSequence(Vector2 directionToPlayer)
	{
		if (_attackCooldownTimer > 0f || _isDashing || _isEvading) return; 

		_isAttacking = true;
		_attackCooldownTimer = AttackCooldown;

		string targetAttackAnim = AttackAnimationName; 
		float dotProductUp = Vector2.Up.Dot(directionToPlayer); 
		float dotProductDown = Vector2.Down.Dot(directionToPlayer); 
		
		const float VerticalThreshold = 0.8f;

		// 1. Check for Top Attack
		if (dotProductUp > VerticalThreshold) 
		{
			_sprite.FlipH = false;
			targetAttackAnim = AttackAnimationNameTop;
		}
		// 2. Check for Bottom Attack
		else if (dotProductDown > VerticalThreshold) 
		{
			_sprite.FlipH = false;
			targetAttackAnim = AttackAnimationNameBottom;
		}
		// 3. Fall back to Horizontal Attacks
		else if (directionToPlayer.X < 0)
		{
			_sprite.FlipH = false; 
			targetAttackAnim = AttackAnimationNameLeft;
		}
		else
		{
			_sprite.FlipH = false; 
			targetAttackAnim = AttackAnimationNameRight;
		}
		
		if (_sprite != null && !_sprite.SpriteFrames.HasAnimation(targetAttackAnim))
		{
			targetAttackAnim = AttackAnimationName; 
			if (_sprite != null)
				_sprite.FlipH = directionToPlayer.X < 0;
		}

		PlayAnim(targetAttackAnim);
		
		_damageTimer.Start();
	}

	private void ApplyDamage()
	{
		if (_player != null && IsInstanceValid(_player))
		{
			float dist = (_player.GlobalPosition - GlobalPosition).Length();
			
			if (dist <= AttackRange) 
			{
				_player.TakeDamage(AttackDamage);
			}
		}
	}

	private void OnAttackAnimationFinished()
	{
		if (_sprite.Animation == AttackAnimationName ||
			_sprite.Animation == AttackAnimationNameLeft ||
			_sprite.Animation == AttackAnimationNameRight ||
			_sprite.Animation == AttackAnimationNameBottom ||
			_sprite.Animation == AttackAnimationNameTop)
		{
			_isAttacking = false;
		}
	}

	private void Die()
	{
		EmitSignal(SignalName.Killed);
		
		// Clean up connections and search timer
		if (_sprite != null &&
			_sprite.IsConnected(
				AnimatedSprite2D.SignalName.AnimationFinished,
				new Callable(this, nameof(OnAttackAnimationFinished))
			))
		{
			_sprite.Disconnect(
				AnimatedSprite2D.SignalName.AnimationFinished,
				new Callable(this, nameof(OnAttackAnimationFinished))
			);
		}

		if (_playerSearchTimer != null)
		{
			_playerSearchTimer.Stop();
			_playerSearchTimer.QueueFree();
		}

		// Clean up all timers
		_damageTimer?.Stop(); _damageTimer?.QueueFree();
		_flashTimer?.Stop(); _flashTimer?.QueueFree();
		_healthBarVisibleTimer?.Stop(); _healthBarVisibleTimer?.QueueFree();
		
		_dashCooldownTimer?.Stop(); _dashCooldownTimer?.QueueFree();
		_dashDurationTimer?.Stop(); _dashDurationTimer?.QueueFree();
		
		_evasionActionTimer?.Stop(); _evasionActionTimer?.QueueFree();
		_evasionDurationTimer?.Stop(); _evasionDurationTimer?.QueueFree();
		
		// Clear particle lists
		_particlePositions.Clear();
		_particleVelocities.Clear();
		_particleLifetimes.Clear();
		_particleMaxLifetimes.Clear();
		_particleSizes.Clear();
		_particleColors.Clear();
		
		// Clean up UI
		_healthBarContainer?.QueueFree();

		QueueFree();
	}

	private void PlayAnim(string anim)
	{
		if (_sprite == null || _isDashing || _isEvading) return; 

		if (anim == AttackAnimationName || anim == AttackAnimationNameLeft || anim == AttackAnimationNameRight || anim == AttackAnimationNameBottom || anim == AttackAnimationNameTop)
		{
			if (_sprite.Animation != anim)
			{
				_sprite.Play(anim, customSpeed: 1.0f, fromEnd: false);
				_sprite.Frame = 0;
			}
			return;
		}

		if (_isAttacking) return;

		string target = anim;

		if (!_sprite.SpriteFrames.HasAnimation(target))
		{
			target = anim.Contains("walk") ? "walk" :
					 anim.Contains("idle") ? "idle" : target;

			if (!_sprite.SpriteFrames.HasAnimation(target))
				return;
		}

		if (_sprite.Animation != target)
			_sprite.Play(target);
	}

	private void _on_attack_area_body_entered(Node2D body) {}
}
